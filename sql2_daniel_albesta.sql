-- ============================================================================================================
-- ============================================================================================================

-- ASSIGNMENT CASES  ||  SQL PART (2)  ||  DAY 5  ||  DANIEL ALBESTA

-- ============================================================================================================
-- ============================================================================================================


-- CASE NUMBER 3:

-- CREATE A NEW SEQUENCE CALLED "msstudents_msstudentsid_seq" ON THE SCHEMA CALLED "public"
-- (*For make it sequential order (auto increment).)

CREATE SEQUENCE public.msstudents_msstudentsid_seq
	START 1
		-- SET THE STARTING POINT OF SEQUENCE TO 1

	INCREMENT 1;
		-- SET THE INCREMENTAL VALUE OF THE SEQUENCE TO 1
			-- (*It means that the sequence value will be increased by 1 each time a new row is appended.)


-- CREATE A NEW TABLE CALLED "msstudents" ON THE SCHEMA CALLED "public"
-- (*ms := master table (table naming convention).)

CREATE TABLE public.msstudents(
	id INT NOT NULL DEFAULT nextval('public.msstudents_msstudentsid_seq'),
		-- DECLARE A NEW COLUMN CALLED "id" WITH THE FOLLOWING SETTING OF:
			-- Takes INT (is an abbreviation of INTEGER) as the DATA TYPE
			-- (range from -2147483648 up to +2147483647).
			-- NOT NULL attribute, it means that the column's value can not be empty or none at all.
			-- DEFAULT attribute, It means that the column's value will always default to the sequence number
				-- generated by the existing sequence called "msstudents_msstudentsid_seq", if we did not
				-- specify it when we populated the table. So it will be filled with a value that starts from
				-- 0 up to n, depending on how many times we input the data (e.g., 1, 2, 3, etc).

	first_name VARCHAR(50) NOT NULL,
		-- DECLARE A NEW COLUMN CALLED "first_name" WITH THE FOLLOWING SETTING OF:
			-- Takes VARCHAR (is an abbrevitation of CHARACTER VARYING) as the data type
			-- (range from 0 up to 50 characters long).
			-- NOT NULL attribute, column's value can not be empty or none at all.

	last_name VARCHAR(50) DEFAULT NULL,
		-- DECLARE A NEW COLUMN CALLED "last_name" WITH THE FOLLOWING SETTING OF:
			-- Takes VARCHAR as the data type (range from 0 up to 50 characters long).
			-- DEFAULT attribute, column's value set to NULL, if we did not specify it when we populated the
			-- table.

	email VARCHAR(30) NOT NULL,
		-- DECLARE A NEW COLUMN CALLED "email" WITH THE FOLLOWING SETTING OF:
			-- Takes VARCHAR as the data type (range from 0 up to 30 characters long).
			-- NOT NULL attribute, column's value can not be empty or none at all.

	age INT DEFAULT 18,
		-- DECLARE A NEW COLUMN CALLED "age" WITH THE FOLLOWING SETTING OF:
			-- Takes INT as the data type (range from -2147483648 up to +2147483647).
			-- DEFAULT attribute, column's value set to 18, if we did not specify it when we populated the
			-- table.

	gender VARCHAR(10),
		-- DECLARE A NEW COLUMN CALLED "gender" WITH THE FOLLOWING SETTING OF:
			-- Takes VARCHAR as the data type (range from 0 up to 10 characters long).

	date_of_birth DATE NOT NULL,
		-- DECLARE A NEW COLUMN CALLED "date_of_birth" WITH THE FOLLOWING SETTING OF:
			-- Takes DATE as the data type (stores as "yyyy-mm-dd" format).
			-- NOT NULL attribute, column's value can not be empty or none at all.

	created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
		-- DECLARE A NEW COLUMN CALLED "created_at" WITH THE FOLLOWING SETTING OF:
			-- Takes TIMESTAMP WITH TIME ZONE as the data type (stores a TIME STAMP as a join format between
			-- DATE and TIME data type, "yyyy-mm-dd hh:mm:ss.ms").
			-- DEFAULT attribute, column's value set to current TIME STAMP with TIME ZONE,
			-- if we did not specify it when we populated the table.

	CONSTRAINT students_id_pkey PRIMARY KEY(id),
		-- INITIALIZE A NEW CONSTRAINT CALLED "students_id_pkey" WITH THE THE FOLLOWING SETTING OF:
			-- Mark the column "id" as the table identifier key (PRIMARY KEY) of the TABLE "msstudents".

	CONSTRAINT check_email_unique UNIQUE(email),
		-- INITIALIZE A NEW CONSTRAINT CALLED "check_email_unique" WITH THE THE FOLLOWING SETTING OF:
			-- Mark the column "email" so the value of that column will always remain different each other
			-- (UNIQUE).

	CONSTRAINT check_gender_value CHECK(gender IN ('male', 'female'))
		-- INITIALIZE A NEW CONSTRAINT CALLED "check_gender_value" WITH THE THE FOLLOWING SETTING OF:
			-- Mark the column "gender" so the value of that column will always remain two of the only values
			-- that are allowed, which are "male" and female".
);


-- ALTER EXISTING SEQUENCE "msstudents_msstudentsid_seq" (1)
-- TO BE OWNED BY EXISTING COLUMN "ID" ON THE TABLE "msstudents"

ALTER SEQUENCE public.msstudents_msstudentsid_seq OWNED BY msstudents.id;


-- DROP EXISTING TABLE "msstudents" AND SEQUENCE "msstudents_msstudentsid_seq"

DROP TABLE IF EXISTS public.msstudents;
DROP SEQUENCE IF EXISTS public.msstudents_msstudentsid_seq;


-- INSERT INTO TABLE "msstudents"
-- (*For testing the table's attributes of data type, not null, and constraints.)

INSERT INTO public.msstudents
	(first_name, last_name, email, age, gender, date_of_birth, created_at)
VALUES('Daniel', 'Albesta', 'albesta7@gmail.com', 23, 'female', '2000-01-16', NOW());


INSERT INTO public.msstudents
	(first_name, email, age, gender, date_of_birth, created_at)
VALUES('Daniel', 'albesta07@gmail.com', 23, 'female', '2000-01-16', NOW());


INSERT INTO public.msstudents
	(first_name, email, age, gender, date_of_birth, created_at)
VALUES('Daniel', 'albesta007@gmail.com', 23, 'male', '2000-01-16', NOW());


INSERT INTO public.msstudents
	(first_name, email, age, gender, date_of_birth)
VALUES('Daniel', 'albesta0007@gmail.com', 23, 'male', '2000-01-16');


INSERT INTO public.msstudents
	(first_name, email, gender, date_of_birth)
VALUES('Daniel', 'albesta00007@gmail.com', 'male', '2000-01-16');


INSERT INTO public.msstudents
	(first_name, email, date_of_birth)
VALUES('Daniel', 'albesta000007@gmail.com', '2000-01-16');


-- ALTER EXISTING SEQUENCE "msstudents_msstudentsid_seq" (2)
-- TO RESET THE SEQUENCE SETTING BACK TO 1 BY DEFAULT

BEGIN WORK;

	ALTER SEQUENCE public.msstudents_msstudentsid_seq RESTART;

	UPDATE public.msstudents
	SET id = DEFAULT;

-- 	ROLLBACK;
	COMMIT;
END WORK;

-- SELECT TABLE "msstudents"

SELECT * FROM public.msstudents



-- ============================================================================================================
-- ============================================================================================================


-- CASE NUMBER 4:

-- ALT. 1

-- CREATE A NEW FUNCTION CALLED "func_mov_genre_count_alt_1" ON THE SCHEMA CALLED "public"
-- (*The purpose of this function is to display how many 'n' movies exists based on the searched movie genre.)

CREATE OR REPLACE FUNCTION public.func_mov_genre_count_alt_1(SEARCHED_GEN_TITLE VARCHAR)
-- "CREATE OR REPLACE" keyword
-- FUNCTION "func_mov_genre_count_alt_1" passing a parameter called "SEARCHED_GEN_TITLE" with VARCHAR DATA
-- TYPE as an argument value.

	RETURNS SMALLINT
	-- Define the RETURN's data type of this function sets as SMALLINT (range from -32768 up to +32767).

	LANGUAGE plpgsql
	-- Define the function's LANGUAGE sets to PLPGSQL (Procedural Language/PostgreSQL)
	-- is a loadable procedural language for the PostgreSQL (ORDBMS)

AS
$$
-- Double DOLLAR symbol, act as the start also as the end of the body of a user-defined function.

	DECLARE
		RES_MOV_GENRE_COUNT SMALLINT;
			-- Declare a variable called "RES_MOV_GENRE_COUNT" with SMALLINT as the data type.
			-- SEMICOLON (;) symbol, act as to execute the function automatically.

	BEGIN
		-- Marks as beginning of the FUNCTION's operation.

		SELECT
			-- SQL's SELECT clause acts to retrieve and return single or multiple tabular data
			-- from one or more tables in the database.

			COUNT(MOV.mov_id) INTO RES_MOV_GENRE_COUNT
				-- SQL's SELECT clause has a COUNT() function that returns how many 'n' number of rows related
				-- to the defined criteria condition of the data in the SQL's WHERE clause.
				-- Assign the return value from COUNT(column "mov_id" on the table "movie") funtion to the
				-- variable "RES_MOV_GENRE_COUNT".

		FROM
			-- SQL's FROM clause acts to retrieve data based on the specific defined tables in the database.

			public.movie AS MOV
				-- The first source of data to be combined is based on the relationship and similarities
				-- between specific columns from both tables.

			INNER JOIN public.movie_genres AS MOV_GEN
				on MOV.mov_id = MOV_GEN.mov_id
				-- The second source of data to be combined is based on the column "mov_id"
				-- (between table "movie" and "movie_genres") using the "INNER JOIN" keyword.
				-- In this case, a column "mov_id" acts like an identifier for the tables and has a specific
				-- relationship between them.
				-- INNER JOIN means that the return of the combination from both tables
				-- ("movie" and "movie_genre") only takes all the data that has a matching value between them.

			INNER JOIN public.genres AS GEN
				on MOV_GEN.gen_id = GEN.gen_id
				-- The third source of data to be combined is based on the column "gen_id".
				-- (between table "movie_genres" and "genres") using the "INNER JOIN" keyword.

		WHERE
			-- SQL's WHERE clause is capable of having multiple criteria for how the result will be filtered.

			GEN.gen_title = SEARCHED_GEN_TITLE
				-- If the data has a specific movie genre based on the parameter, then it will be returned.

		GROUP BY
			-- SQL's GROUP BY clause is used in collaboration with SQL's SELECT clause in order to group the
			-- rows of the data on specific tables that have an identical value based on the specific defined
			-- column data.

			GEN.gen_title;
				-- Grouped by the column "gen_title" (table "genres").

		RETURN RES_MOV_GENRE_COUNT;
		-- Return the value of the variable "RES_MOV_GENRE_COUNT" that has been declared and assigned before
		-- to the place where the function is called from.

	END;
	-- Marks as ending of the FUNCTION's operation.

$$;
-- DOUBLE DOLLAR sign ($$) act as the START also as the END of the body of user-defined function.


-- TAKE NOTES OR COMMENT ON THE FUNCTION "func_mov_genre_count_alt_1"

COMMENT ON FUNCTION public.func_mov_genre_count_alt_1 IS
'FUNCTION TO COUNT ALL MOVIES BASED ON THE SEARCHED MOVIE GENRE AND RETURN SINGLE COLUMN AS ALT 1';


-- DROP THE EXISTING FUNCTION "func_mov_genre_count_alt_1"

DROP FUNCTION IF EXISTS public.func_mov_genre_count_alt_1


SELECT public.func_mov_genre_count_alt_1('Adventure') AS "Total Movies Based on Searched Genre"


-- ALT. 2

-- CREATE A NEW FUNCTION CALLED "func_mov_genre_count_alt_2" ON THE SCHEMA CALLED "public"
-- (*The purpose of this function is to display how many 'n' movies exists based on the searched movie genre.)

CREATE OR REPLACE FUNCTION public.func_mov_genre_count_alt_2(SEARCHED_GEN_TITLE VARCHAR)
-- "CREATE OR REPLACE" keyword
-- FUNCTION "func_mov_genre_count_alt_1" passing a parameter called "SEARCHED_GEN_TITLE" with VARCHAR DATA TYPE
-- as an argument value.

	RETURNS RECORD
	-- Define the RETURN's data type of this function sets as RECORD which merely serve as a result set's
	-- placeholder rows.

	LANGUAGE plpgsql
	-- Define the function's LANGUAGE sets to PLPGSQL (Procedural Language/PostgreSQL)
	-- is a loadable procedural language for the PostgreSQL (ORDBMS)

AS
$$
-- Double DOLLAR symbol, act as the start also as the end of the body of a user-defined function.

	DECLARE 
		RES_MOV_GENRE_COUNT RECORD;
			-- Declare a variable called "RES_MOV_GENRE_COUNT" with RECORD keyword.
			-- SEMICOLON (;) symbol, act as to execute the function automatically.

	BEGIN
		-- Marks as beginning of the FUNCTION's operation.

		SELECT
			-- SQL's SELECT clause acts to retrieve and return single or multiple tabular data
			-- from one or more tables in the database.

			INITCAP(GEN.gen_title)::VARCHAR, COUNT(MOV.mov_id)::SMALLINT INTO RES_MOV_GENRE_COUNT
				-- SQL's SELECT clause has a COUNT() function that returns how many 'n' number of rows related
				-- to the defined criteria condition of the data in the SQL's WHERE clause.
				-- Assign the return value from column "gen_title" (table "genres") formatted in Title Case
				-- (VARCHAR data type)
				-- using INITCAP() function and COUNT(column "mov_id" on the table "movie") funtion
				-- (SMALLINT data type)
				-- to the variable "RES_MOV_GENRE_COUNT" in the form of single tabular data.

 		FROM
			-- SQL's FROM clause acts to retrieve data based on the specific defined tables in the database.

			public.movie AS MOV
				-- The first source of data to be combined is based on the relationship and similarities
				-- between specific columns from both tables.

			INNER JOIN public.movie_genres AS MOV_GEN
				on MOV.mov_id = MOV_GEN.mov_id
				-- The second source of data to be combined is based on the column "mov_id"
				-- (between table "movie" and "movie_genres") using the "INNER JOIN" keyword.
				-- In this case, a column "mov_id" acts like an identifier for the tables and has a specific
				-- relationship between them.
				-- INNER JOIN means that the return of the combination from both tables
				-- ("movie" and "movie_genre")
				-- only takes all the data that has a matching value between them.

			INNER JOIN public.genres AS GEN
				on MOV_GEN.gen_id = GEN.gen_id
				-- The third source of data to be combined is based on the column "gen_id"
				-- (between table "movie_genres" and "genres") using the "INNER JOIN" keyword.

		WHERE
			-- SQL's WHERE clause is capable of having multiple criteria for how the result will be filtered.

			GEN.gen_title = SEARCHED_GEN_TITLE
				-- If the data has a specific movie genre based on the parameter, then it will be returned.

		GROUP BY
			-- SQL's GROUP BY clause is used in collaboration with SQL's SELECT clause in order to group the
			-- rows of the data on specific tables that have an identical value based on the specific
			-- defined column data.

			GEN.gen_title;
				-- Grouped by the column "gen_title".

		RETURN RES_MOV_GENRE_COUNT;
		-- Return the value of the variable "RES_MOV_GENRE_COUNT" that has been declared and assigned before
		-- to the place where the function is called from.

	END;
	-- Marks as ending of the FUNCTION's operation.

$$;
-- DOUBLE DOLLAR sign ($$) act as the START also as the END of the body of user-defined function.


-- TAKE NOTES OR COMMENT ON THE FUNCTION "func_mov_genre_count_alt_2"

COMMENT ON FUNCTION public.func_mov_genre_count_alt_2 IS
'FUNCTION TO COUNT ALL MOVIES BASED ON THE SEARCHED MOVIE GENRE AND RETURN MULTIPLE COLUMNS AS ALT 2';


-- DROP THE EXISTING FUNCTION "func_mov_genre_count_alt_2"

DROP FUNCTION IF EXISTS public.func_mov_genre_count_alt_2


-- TESTING ON THE FUNCTION "func_mov_genre_count_alt_2"

-- (*Divide the function's return value into multiple variables with different data types 
-- (VARCHAR and SMALLINT)
-- based on the position index and data type of the assigned values inside the function.)

SELECT
	MOVIE_GENRE_TITLE AS "Movie Genre",
	SEARCHED_GENRE AS "Total Movies Based on Searched Genre"

FROM
	public.func_mov_genre_count_alt_2('Adventure') AS (
		MOVIE_GENRE_TITLE VARCHAR,
		SEARCHED_GENRE SMALLINT
	)


-- ============================================================================================================
-- ============================================================================================================


-- CASE NUMBER 5:

-- CREATE A NEW RAW QUERY TO DISPLAY ALL MOVIE DETAIL DATA ON THE DATABASE "movie"
-- (*This raw data does not yet implement all the priciples of revamping a query in order to make it more
-- efficient and robust.)

SELECT
	*

FROM
	public.movie AS MOV


-- REVAMPING A QUERY BASED ON THE (#1) FIRST PRINCIPLE: "Never select data without where."

SELECT
	*

FROM
	public.movie AS MOV

WHERE
	-- SQL's WHERE clause is added to adhere to the first principle of revamping a query.

	MOV.mov_year IN (1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004)

	AND (MOV.mov_time / 10) >= 10


-- REVAMPING A QUERY BASED ON THE (#2) SECOND PRINCIPLE: "Never use select (*)."

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"
	-- Added several columns to make the process of retrieve and return single or multiple tabular data from
	-- one or more tables in the database is efficient rather than by using (*) to adhere to the
	-- second principle of revamping a query.

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004)

	AND (MOV.mov_time / 10) >= 10


-- REVAMPING A QUERY BASED ON THE (#3) THIRD PRINCIPLE: "Never do processing data in the where filter."

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004)

	AND MOV.mov_time >= (10 * 10)
	-- Remove the algorithm from a column that has a comparison operator implemented in it to adhere to the
	-- third principle of revamping a query.


-- REVAMPING A QUERY BASED ON THE (#4) FOURTH PRINCIPLE: "Never use too many IN values."

-- (#1) FIRST SPLIT MULTIPLE CONDITIONS DATA:

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1990, 1991, 1992)
	-- Multiple conditions stated on the IN() function are split into a range of 3 up to 5 values
	-- to adhere to the fourth principle of revamping a query.

	AND MOV.mov_time >= (10 * 10)


-- (#2) SECOND SPLIT MULTIPLE CONDITIONS DATA:

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1993, 1994, 1995)

	AND MOV.mov_time >= (10 * 10)


-- (#3) THIRD SPLIT MULTIPLE CONDITIONS DATA:

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1996, 1997, 1998)

	AND MOV.mov_time >= (10 * 10)


-- (#4) FOURTH SPLIT MULTIPLE CONDITIONS DATA:

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (1999, 2000, 2001)

	AND MOV.mov_time >= (10 * 10)


-- (#5) FIFTH SPLIT MULTIPLE CONDITIONS DATA:

SELECT
	MOV.mov_title AS "Movie Title",
	MOV.mov_year AS "Movie Year",
	MOV.mov_time AS "Movie Time Duration"

FROM
	public.movie AS MOV

WHERE
	MOV.mov_year IN (2002, 2003, 2004)

	AND MOV.mov_time >= (10 * 10)


-- ============================================================================================================
-- ============================================================================================================


-- CASE NUMBER 6:

-- SELECT TABLE "ninja" WITH EXPLAIN ANALYZE
-- (*To produce detailed information on how the query works, include planning time and execution time.)
-- (*Before applying the special index for the email column.)

-- BEFORE APPLIYING, PLANNING TIME TAKE: 0.057 ms, EXECUTION TIME: 0.022 ms (SAMPLE TESTING).

EXPLAIN ANALYZE
SELECT
	NIN.nama,
	NIN.desa,
	NIN.email

FROM
	public.ninja AS NIN

WHERE
	NIN.email = 'hinata@mail.com'	


-- CREATE INDEX "idx_ninja_email" ON TABLE "ninja"

CREATE INDEX idx_ninja_email
	ON public.ninja(
		email
	)


-- SET enable_seqscan OFF
-- (*Basically, it disabled the sequence scan so the created index, "idx_ninja_email", would work.)

SET enable_seqscan = Off


-- SELECT TABLE "ninja" WITH EXPLAIN ANALYZE
-- (*To produce detailed information on how the query works, include planning time and execution time.)
-- (*After applying the special index for the email column.)

-- AFTER APPLIYING, PLANNING TIME TAKE: 0.053 ms, EXECUTION TIME: 0.028 ms (SAMPLE TESTING).

-- So, the conclusion is that the performance effect of the index created does not increase the
-- performance of the table search but slows down a little due to the small content of the table.
-- However, if the contents of the table are large, the effect will speed up the search for the table.

EXPLAIN ANALYZE
SELECT
	NIN.nama,
	NIN.desa,
	NIN.email

FROM
	public.ninja AS NIN

WHERE
	NIN.email = 'hinata@mail.com'


-- DROP INDEX "idx_ninja_email"

DROP INDEX IF EXISTS idx_ninja_email


-- SET enable_seqscan ON
-- (*Basically, it enabled the sequence scan so the created index, "idx_ninja_email", would not work.)

SET enable_seqscan = ON


-- ============================================================================================================
-- ============================================================================================================


-- CASE NUMBER 7:

-- CREATE A NEW QUERY TO DETERMINE WHAT MOVIE GENRE HAS THE HIGHEST RATING AMONG OTHERS.

SELECT
	RES_MOV_RATING_HIGHEST_GENRE.MovieGenre AS "List of All Movie Genres",
	-- Retrieve and return related data based on the column alias "MovieGenre"
	-- the tabular data result on the FROM's single subquery.

	CAST(
		DENSE_RANK() OVER(
			ORDER BY RES_MOV_RATING_HIGHEST_GENRE.MovieRating DESC
		) AS SMALLINT
	) AS "Ranked by Movie Ratings"
	-- Retrieve and return related data based on the column alias "MovieRating" as the tabular data result on
	-- the FROM's single subquery in descending order (the highest value first).
	-- After all the data is gathered, it will be ranked using the DENSE_RANK() function.
	-- This function will assign the same value to identical element data if there are two or more of them,
	-- and the following rank value will be the following consecutive number.

FROM
	(

		SELECT
			GEN.gen_title AS MovieGenre,
				-- Retrieve and return related data based on the column "gen_title" (table "genres").

			MAX(RAT.rev_stars) AS MovieRating
				-- Retrieve and return related data based on the column "rev_start" (table "rating").
				-- Filtered to return the highest data value possible using the MAX() function
				-- based on each data row in the column "gen_title".

		FROM 
			public.movie AS MOV
				-- The first source of data to be combined is based on the relationship and similarities
				-- between specific columns from both tables.

			INNER JOIN public.movie_genres AS MOV_GEN
				on MOV.mov_id = MOV_GEN.mov_id
				-- The second source of data to be combined is based on the column "mov_id"
				-- (between table "movie" and "movie_genres") using the "INNER JOIN" keyword.

			INNER JOIN public.genres AS gEN
				on MOV_GEN.gen_id = GEN.gen_id
				-- The third source of the data to be combined is based on the column "gen_id"
				-- (between table "movie_genres" and "genres") using the "INNER JOIN" keyword.

			INNER JOIN public.rating AS RAT
				on MOV.mov_id = RAT.mov_id
				-- The fourth source of data to be combined is based on the column "mov_id"
				-- (between table "movie" and "rating") using the "INNER JOIN" keyword.

		GROUP BY
			GEN.gen_title
				-- Grouped by the column "gen_title".

	) AS RES_MOV_RATING_HIGHEST_GENRE
	-- Contains a single subquery to be retrieved, which produced tabular data of the highest rating value on
	-- each movie genre.


-- ============================================================================================================
-- ============================================================================================================